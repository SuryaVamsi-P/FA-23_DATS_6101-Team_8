---
title: "Team 8 project 2 - model building"
author: "Team 8"
# date: "today"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    number_sections: false
    toc: yes
    toc_depth: 3
    toc_float: yes
  #pdf_document:
   # toc: yes
    #toc_depth: '3'
---

```{r init, include=FALSE}
# some of common options (and the defaults) are: 
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right', 
library(ezids)
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, message = F)
options(scientific=T, digits = 3) 
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:



```{r}
g<-read.csv("C:\\Users\\hp\\Documents\\GitHub\\FA-23_DATS_6101-Team_8\\Dataset.csv")
```


```{r}
total_missing_values <- colSums(is.na(g) | g == "", na.rm = TRUE)
#print(total_missing_values)

columns_to_drop <- names(total_missing_values[total_missing_values > 21500])
g <- g[, !(names(g) %in% columns_to_drop)]

```


```{r}
par(mfrow = c(2, 2))  # Set up a 2x2 grid for multiple plots
for (col in names(g)) {
  if (is.numeric(g[[col]])) {
    hist(g[[col]], main = col, col = "lightblue", border = "black")
    qqnorm(g[[col]], main = col)
    qqline(g[[col]])
  }
}
```


```{r}
library(dplyr)
columns_to_convert <- c("arf_apache", "gcs_eyes_apache", "gcs_motor_apache", "gcs_unable_apache", "gcs_verbal_apache", "intubated_apache", "ventilated_apache", "aids", "cirrhosis", "diabetes_mellitus", "hepatic_failure", "immunosuppression", "leukemia", "lymphoma", "solid_tumor_with_metastasis", "ethnicity", "gender", "hospital_admit_source", "icu_admit_source", "apache_3j_bodysystem", "apache_2_bodysystem", "elective_surgery", "apache_post_operative", "icu_stay_type", "icu_type", "readmission_status")

g <- g %>% mutate_at(vars(columns_to_convert), factor)
```


```{r}
g[g == ""] <- NA

factor_vars <- sapply(g, is.factor)

for (col in names(g)[factor_vars]) {
  mode_value <- names(sort(table(g[[col]]), decreasing = TRUE))[1]
  g[[col]][is.na(g[[col]])] <- mode_value
}
numeric_columns_to_impute <- c("apache_2_diagnosis", "map_apache", "resprate_apache", "apache_4a_hospital_death_prob", "apache_4a_icu_death_prob")

for (col in numeric_columns_to_impute) {
  mode_val <- names(sort(table(g[[col]], useNA = "ifany"), decreasing = TRUE))[1]
  g[[col]][is.na(g[[col]])] <- ifelse(is.na(g[[col]]), mode_val, g[[col]])
}
```


```{r}
columns_to_impute <- c("age", "bmi", "weight", "apache_3j_diagnosis", "glucose_apache", "d1_mbp_noninvasive_max", "d1_resprate_max", "d1_spo2_max", "d1_spo2_min", "d1_temp_max", "d1_temp_min", "h1_diasbp_max", "h1_diasbp_noninvasive_max", "h1_resprate_max", "h1_spo2_max", "h1_spo2_min", "d1_bun_max", "d1_bun_min", "d1_creatinine_max", "d1_creatinine_min", "d1_glucose_max", "d1_glucose_min", "d1_platelets_max", "d1_platelets_min", "d1_potassium_max", "d1_sodium_min", "bun_apache", "creatinine_apache")

for (col in columns_to_impute) {
  if (is.numeric(g[[col]])) {
    median_value <- median(g[[col]], na.rm = TRUE)
    g[[col]][is.na(g[[col]])] <- median_value
  }
}
```


```{r}
columns_to_impute1 <- c("height", "heart_rate_apache", "temp_apache", "d1_diasbp_max", "d1_diasbp_min", "d1_diasbp_noninvasive_max", "d1_diasbp_noninvasive_min", "d1_heartrate_max", "d1_heartrate_min", "d1_mbp_max", "d1_mbp_min", "d1_mbp_noninvasive_min", "d1_resprate_min", "d1_sysbp_max", "d1_sysbp_min", "d1_sysbp_noninvasive_max", "d1_sysbp_noninvasive_min", "h1_diasbp_min", "h1_diasbp_noninvasive_min", "h1_heartrate_max", "h1_heartrate_min", "h1_mbp_max", "h1_mbp_min", "h1_mbp_noninvasive_max", "h1_mbp_noninvasive_min", " h1_resprate_min", "h1_sysbp_max", "h1_sysbp_min", "h1_sysbp_noninvasive_max", "h1_sysbp_noninvasive_min", "d1_calcium_max", "d1_calcium_min", "d1_hco3_max", "d1_hco3_min", "d1_hemaglobin_max", "d1_hemaglobin_min", "d1_hematocrit_max", "d1_hematocrit_min", "d1_potassium_min", "d1_sodium_max", "d1_wbc_max", "d1_wbc_min", "hematocrit_apache", "sodium_apache")

# Loop through specified columns and impute mean
for (col in columns_to_impute1) {
  # Check if the column is numeric
  if (is.numeric(g[[col]])) {
    mean_value <- mean(g[[col]], na.rm = TRUE)
    g[[col]][is.na(g[[col]])] <- mean_value
  }
}
g[["h1_resprate_min"]][is.na(g[["h1_resprate_min"]])] <- mean(g[["h1_resprate_min"]], na.rm = TRUE)
```

